{"name":"Bubblegum","tagline":"java micro web framework","body":"Bubblegum - a micro web framework for java\r\n==========================================\r\n\r\nOnly 35KB and does not depend on jars other than the servlet api.\r\nIt's only purpose is to match routes to handlers.\r\n\r\nBubblegum is inspired by [Spark], but there are important differences. In Bubblegum:\r\n- Paths are matched case-sensitive\r\n- Requests can be matched on any of its properties for example on the Accept or Content-type headers\r\n- Handlers can throw exceptions\r\n- Filters are more servlet Filter-like (but with more expressive filter mapping)\r\n- A JdbcHelper provides request-scoped jdbc transactions (Optional - it's a bubblegum Filter)\r\n\r\nGet the jar at <http://janickreynders.be/bubblegum>\r\n\r\n\r\nUsage\r\n-----\r\n\r\n1) Implement the App interface\r\n\r\n```java\r\npackage com.yourpackage.test;\r\n\r\nimport be.janickreynders.bubblegum.*;\r\n\r\npublic class TestApp implements App {\r\n    @Override\r\n    public Config createConfig() {\r\n        Config on = new Config();\r\n\r\n        on.get(\"/hello/:name\", new Handler() {\r\n            @Override\r\n            public void handle(Request req, Response resp) throws Exception {\r\n                resp.ok(\"Hello \" + req.param(\"name\") + \"!\");\r\n            }\r\n        });\r\n\r\n        return on;\r\n    }\r\n}\r\n```\r\n\r\n2) Add Bubblegum to your web.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n           xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\r\n           version=\"2.5\">\r\n\r\n    <filter>\r\n        <filter-name>Bubblegum</filter-name>\r\n        <filter-class>be.janickreynders.bubblegum.Bubblegum</filter-class>\r\n        <init-param>\r\n            <param-name>app</param-name>\r\n            <param-value>com.yourpackage.test.TestApp</param-value>\r\n        </init-param>\r\n    </filter>\r\n\r\n    <filter-mapping>\r\n        <filter-name>Bubblegum</filter-name>\r\n        <url-pattern>/*</url-pattern>\r\n        <dispatcher>REQUEST</dispatcher>\r\n        <dispatcher>FORWARD</dispatcher>\r\n        <dispatcher>INCLUDE</dispatcher>\r\n        <dispatcher>ERROR</dispatcher>\r\n    </filter-mapping>\r\n</web-app>\r\n```\r\n\r\n3) That's it! Deploy and point your browser to http://localhost/hello/chuck\r\n\r\nCopyright and License\r\n---------------------\r\nCopyright &copy; 2012-, Janick Reynders. Licensed under [MIT License].\r\n\r\n\r\nMore Examples\r\n-------------\r\n\r\n```java\r\nimport be.janickreynders.bubblegum.*;\r\n\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\nimport static be.janickreynders.bubblegum.Filters.*;\r\nimport static be.janickreynders.bubblegum.Handlers.*;\r\nimport static be.janickreynders.bubblegum.Matchers.*;\r\n\r\npublic class Examples implements App {\r\n    @Override\r\n    public Config createConfig() {\r\n        Config on = new Config();\r\n\r\n        // forward a request to a jsp\r\n        on.get(\"/forward/me\", forward(\"/forwarded.jsp\"));\r\n\r\n        // forward a request to a jsp in WEB-INF/jsp\r\n        on.get(\"/forward/me2\", forward(\"/WEB-INF/jsp/forwarded.jsp\"));\r\n\r\n        // forward a request to another handler\r\n        on.get(\"/forward/again\", forward(\"/textcontent\"));\r\n\r\n        // match the paths '/different/this' and '/different/some-other-thing'\r\n        //   but not '/different/that/or/this'\r\n        on.get(\"/different/*\", forward(\"/forwarded.html\"));\r\n\r\n        // match any of '/multiple/this/levels', '/multiple/this/or/that/levels' ,...\r\n        on.get(\"/multiple/**/levels\", forward(\"/forwarded.txt\"));\r\n\r\n        // redirect to a different url\r\n        on.get(\"/redirect/me\", redirect(\"/redirected\"));\r\n\r\n        // using a path variable\r\n        on.get(\"/collection/:id\", new Handler() {\r\n            @Override\r\n            public void handle(Request req, Response resp) throws Exception {\r\n                resp.ok(\"you requested: \" + req.param(\"id\"));\r\n            }\r\n        });\r\n\r\n        // set the content type of the response\r\n        on.get(\"/textcontent\", new Handler() {\r\n            @Override\r\n            public void handle(Request req, Response resp) throws Exception {\r\n                resp.type(\"text/plain\");\r\n                resp.ok(\"You are getting a text response\");\r\n            }\r\n        });\r\n\r\n        // post to a url\r\n        on.post(\"/collection\", new Handler() {\r\n            @Override\r\n            public void handle(Request req, Response resp) throws Exception {\r\n                String value = req.queryParam(\"inputFieldName\");\r\n\r\n                resp.ok(\"you posted: \" + value);\r\n            }\r\n        });\r\n\r\n        // another http method\r\n        on.delete(\"/collection/:id\", new Handler() {\r\n            @Override\r\n            public void handle(Request req, Response resp) throws Exception {\r\n                resp.ok(\"you deleted: \" + req.param(\"id\"));\r\n            }\r\n        });\r\n\r\n\r\n        // different response for different request Accept headers\r\n        on.get(\"/variant\", accept(\"text/html\"), new Handler() {\r\n            @Override\r\n            public void handle(Request req, Response resp) throws Exception {\r\n                resp.vary(\"Accept\");\r\n                resp.ok(\"<html><body> This is the html variant </body></html>\");\r\n            }\r\n        });\r\n\r\n        on.get(\"/variant\", accept(\"application/json\"), new Handler() {\r\n            @Override\r\n            public void handle(Request req, Response resp) throws Exception {\r\n                resp.vary(\"Accept\");\r\n                resp.ok(\"{ \\\"message\\\": \\\"This is the json variant\\\" }\");\r\n            }\r\n        });\r\n\r\n        // interpreting different request body content types\r\n        on.get(\"/requestbody\", contentType(\"application/x-www-form-urlencoded\"), new Handler() {\r\n            @Override\r\n            public void handle(Request req, Response resp) throws Exception {\r\n                // get params with req.queryParam();\r\n            }\r\n        });\r\n\r\n        on.get(\"/requestbody\", contentType(\"application/json\"), new Handler() {\r\n            @Override\r\n            public void handle(Request req, Response resp) throws Exception {\r\n                // parse the json in req.body()\r\n            }\r\n        });\r\n\r\n        // match multiple http methods, and return a status code\r\n        on.route(\"/multiple-methods\", any(method(\"post\"), method(\"put\"), method(\"delete\")),\r\n            status(HttpServletResponse.SC_FORBIDDEN));\r\n\r\n\r\n        /********************** filter examples **********************/\r\n\r\n        // cache /js/thirdparty/** forever\r\n        on.apply(\"/js/thirdparty/**\", cacheNeverExpires());\r\n\r\n        // forward to an error jsp on a certain exception\r\n        on.apply(catchAndHandle(IllegalStateException.class, forward(\"/oops.jsp\")));\r\n\r\n        return on;\r\n    }\r\n}\r\n```\r\n\r\nJdbc helper\r\n-----------\r\nJdbcHelper contains some convenience methods for querying a rdbms. If you configure JdbcHelper as a bubblegum filter\r\nit will always return the same connection during a request (the connection is bound to the thread).\r\nAfter the request the transaction is committed (or rolled back in case the handler threw an exception)\r\nand the connection will be closed.\r\n\r\n```java\r\nimport be.janickreynders.bubblegum.*;\r\nimport be.janickreynders.bubblegum.jdbc.JdbcHelper;\r\n\r\nimport javax.naming.InitialContext;\r\nimport javax.naming.NamingException;\r\nimport javax.sql.DataSource;\r\n\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\n\r\nimport static be.janickreynders.bubblegum.Matchers.accept;\r\nimport static be.janickreynders.bubblegum.jdbc.JdbcHelper.withDbConnection;\r\n\r\npublic class JdbcExample implements App {\r\n    @Override\r\n    public Config createConfig() {\r\n        final JdbcHelper db = new JdbcHelper(getDataSource());\r\n\r\n        Config on = new Config();\r\n\r\n        on.apply(db); // JdbcHelper is a filter that returns the same open connection during your request\r\n                      // It will commit your transaction after the request and closes the connection\r\n\r\n        on.post(\"/insertSomething\", accept(\"text/html\"), new Handler() {\r\n            @Override\r\n            public void handle(Request req, Response resp) throws Exception {\r\n                String value1 = req.queryParam(\"inputFieldName1\");\r\n                String value2 = req.queryParam(\"inputFieldName2\");\r\n                db.update(\"insert into my_table (value1, value2) values (?, ?)\", value1, value2);\r\n\r\n                resp.ok(\"you inserted: \" + value1 + \" and \" + value2);\r\n            }\r\n        });\r\n\r\n        on.get(\"/queryValue2/:value1\", accept(\"text/html\"), new Handler() {\r\n            @Override\r\n            public void handle(Request req, Response resp) throws Exception {\r\n                String value1 = req.param(\"value1\");\r\n                String value2 = db.getString(\"select value2 from my_table where value1 = ?\", value1);\r\n\r\n                resp.ok(value2);\r\n            }\r\n        });\r\n\r\n        on.post(\"/doSomethingAsynchronousInOneTransaction\", accept(\"text/html\"), new Handler() {\r\n            @Override\r\n            public void handle(Request req, Response resp) throws Exception {\r\n                executor.execute(withDbConnection(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        db.update(\"insert into this_table (some_col) values (?)\", \"one thing\");\r\n                        db.update(\"insert into that_table (some_col) values (?)\", \"another thing\");\r\n                    }\r\n                }));\r\n\r\n                resp.ok(\"it's running\");\r\n            }\r\n        });\r\n\r\n        return on;\r\n    }\r\n\r\n    private DataSource getDataSource() {\r\n        try {\r\n            return(DataSource) new InitialContext().lookup(\"java:/comp/env/jdbc/yourDatasourceNameInJNDI\");\r\n        } catch (NamingException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n        // you could also just create your datasource here instead of having one configured in JNDI\r\n    }\r\n\r\n    public JdbcExample() {\r\n        executor = Executors.newSingleThreadExecutor();\r\n    }\r\n\r\n    private final ExecutorService executor;\r\n}\r\n```\r\n\r\n[MIT License]: https://github.com/janickr/bubblegum/raw/master/LICENSE.txt\r\n[Spark]: https://github.com/perwendel/spark\r\n","google":"UA-37769242-1","note":"Don't delete this file! It's used internally to help with page regeneration."}